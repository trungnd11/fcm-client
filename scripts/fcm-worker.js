#!/usr/bin/env node

// eslint-disable-next-line no-redeclare
/* global process */

import { readFileSync, writeFileSync, existsSync, mkdirSync } from "node:fs";
import { dirname } from "node:path";
import { loadConfig, DEFAULT_FIREBASE_CONFIG, DEFAULT_VAPID_KEY } from "./worker-config.js";
import { handleUpdateConfig } from "./override-config.js";

// Service worker template
const SERVICE_WORKER_TEMPLATE = `/* eslint-disable no-undef */
// Generated by fcm-worker script
importScripts(
  'https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js',
);
importScripts(
  'https://www.gstatic.com/firebasejs/10.12.2/firebase-messaging-compat.js',
);

console.log('[SW] Firebase messaging service worker starting...');

firebase.initializeApp({{FIREBASE_CONFIG}});

console.log('[SW] Firebase initialized');

const messaging = firebase.messaging();

console.log('[SW] Messaging instance created');

messaging.onBackgroundMessage(function (payload) {
  console.log(
    '[SW] Received background message:',
    payload,
  );
  
  const notificationTitle = payload.notification?.Content || 'New Message';
  const notificationOptions = {
    body: payload.notification?.Details || 'You have a new message',
    icon: 'https://static-dev.baohiemngoinhaxanh.vn/pub/isr/2025/7/1753411741_nnx-logo.png',
    badge: 'https://static-dev.baohiemngoinhaxanh.vn/pub/isr/2025/7/1753411741_nnx-logo.png',
    image: 'https://static-dev.baohiemngoinhaxanh.vn/pub/isr/2025/7/1753411741_nnx-logo.png',
    tag: 'fcm-notification',
    data: payload.data || {},
  };

  console.log('[SW] Showing notification:', notificationTitle, notificationOptions);

  // Show notification
  self.registration.showNotification(notificationTitle, notificationOptions);

  // Send message via BroadcastChannel
  if ('BroadcastChannel' in self) {
    const channel = new BroadcastChannel('{{BROADCAST_CHANNEL_NAME}}');
    channel.postMessage({
      type: 'FCM_BACKGROUND_NOTIFICATION',
      payload: {
        from: payload.from,
        messageId: payload.messageId,
        notification: payload.notification,
        collapseKey: payload.collapseKey,
      }
    });
    console.log('[SW] Message sent via BroadcastChannel');
  } else {
    // Fallback: use postMessage
    self.clients.matchAll().then((clients) => {
      clients.forEach((client) => {
        client.postMessage({
          type: 'FCM_BACKGROUND_NOTIFICATION',
          payload: {
            from: payload.from,
            messageId: payload.messageId,
            notification: payload.notification,
            collapseKey: payload.collapseKey,
          }
        });
      });
    });
    console.log('[SW] Message sent via postMessage');
  }
});

console.log('[SW] Background message handler registered');
`;

const SERVICE_WORKER_OUTPUT_PATH = "./public/firebase-messaging-sw.js";

function showHelp() {
  console.log(`
FCM Service Worker Manager

Usage: node scripts/fcm-worker.js <command> [options]

Commands:
  generate [output]     Generate service worker file
  validate              Validate existing service worker
  update-config         Update Firebase configuration
  help                  Show this help message

Options:
  --config <file>       Path to Firebase config file (JSON)
  --output <path>       Output path for generated service worker

Examples:
  node scripts/fcm-worker.js generate
  node scripts/fcm-worker.js generate --output ./public/sw.js
  node scripts/fcm-worker.js validate
`);
}

function loadFirebaseConfig(configPath) {
  if (!configPath) {
    // Use config from new system
    return loadConfig();
  }

  try {
    if (!existsSync(configPath)) {
      // If file doesn't exist, return default config to create new file
      return {
        firebase: DEFAULT_FIREBASE_CONFIG,
        vapidKey: DEFAULT_VAPID_KEY,
        broadcastChannelName: "fcm-notifications",
      };
    }

    const configContent = readFileSync(configPath, "utf8");
    const config = JSON.parse(configContent);

    // Support both old and new structure
    if (config.firebase) {
      return {
        firebase: config.firebase,
        vapidKey: config.vapidKey,
        broadcastChannelName: config.broadcastChannelName || "fcm-notifications",
      };
    }

    return {
      firebase: config,
      vapidKey: config.vapidKey,
      broadcastChannelName: config.broadcastChannelName || "fcm-notifications",
    };
  } catch (error) {
    console.error(`‚ùå Error loading config file: ${error.message}`);
    process.exit(1);
  }
}

function generateServiceWorker(config, outputPath = SERVICE_WORKER_OUTPUT_PATH) {
  try {
    // Ensure outputPath is string
    if (!outputPath || typeof outputPath !== "string") {
      outputPath = SERVICE_WORKER_OUTPUT_PATH;
    }

    // Ensure output directory exists
    const outputDir = dirname(outputPath);
    if (!existsSync(outputDir)) {
      mkdirSync(outputDir, { recursive: true });
    }

    // Create service worker content
    let serviceWorkerContent = SERVICE_WORKER_TEMPLATE.replace(
      "{{FIREBASE_CONFIG}}",
      JSON.stringify(config.firebase, null, 2)
    );

    serviceWorkerContent = serviceWorkerContent.replace(
      "{{BROADCAST_CHANNEL_NAME}}",
      config.broadcastChannelName || "fcm-notifications"
    );

    // Write file
    writeFileSync(outputPath, serviceWorkerContent, "utf8");

    console.log(`‚úÖ Service worker generated successfully: ${outputPath}`);
    console.log(`üìã Firebase config used:`);
    console.log(JSON.stringify(config.firebase, null, 2));
    console.log(`üì° Broadcast channel: ${config.broadcastChannelName || "fcm-notifications"}`);

    // Add information when installed as dependency
    if (process.env.FCM_RSLIB_INSTALLED) {
      console.log(`\nüì¶ This service worker was generated by fcm-rslib package`);
    }
  } catch (error) {
    console.error(`‚ùå Error generating service worker: ${error.message}`);
    process.exit(1);
  }
}

function updateConfig(configPath) {
  try {
    const config = loadFirebaseConfig(configPath);

    // Create sample config file if not exists
    if (!configPath) {
      configPath = "./src/config/firebase-message.json";
    }

    if (!existsSync(configPath)) {
      // Ensure directory exists
      const configDir = dirname(configPath);
      if (!existsSync(configDir)) {
        mkdirSync(configDir, { recursive: true });
        console.log(`‚úÖ Created directory: ${configDir}`);
      }

      // Create config with new structure
      const newConfig = {
        firebase: DEFAULT_FIREBASE_CONFIG,
        vapidKey: DEFAULT_VAPID_KEY,
        storageKey: "fcm-notifications",
        broadcastChannelName: "fcm-notifications",
        customEventName: "fcm-notification",
      };

      writeFileSync(configPath, JSON.stringify(newConfig, null, 2), "utf8");
      console.log(`‚úÖ Created config file: ${configPath}`);
    } else {
      console.log(`‚úÖ Config file already exists: ${configPath}`);
    }

    console.log(`üìã Current Firebase configuration:`);
    console.log(JSON.stringify(config.firebase, null, 2));
    console.log(`üì° Broadcast channel: ${config.broadcastChannelName || "fcm-notifications"}`);
  } catch (error) {
    console.error(`‚ùå Error updating config: ${error.message}`);
    process.exit(1);
  }
}

function validateServiceWorker(swPath = SERVICE_WORKER_OUTPUT_PATH) {
  try {
    // Ensure swPath is string
    if (!swPath || typeof swPath !== "string") {
      swPath = SERVICE_WORKER_OUTPUT_PATH;
    }

    if (!existsSync(swPath)) {
      console.error(`‚ùå Service worker not found: ${swPath}`);
      process.exit(1);
    }

    const content = readFileSync(swPath, "utf8");

    // Check required components
    const checks = [
      { name: "Firebase App Import", pattern: /firebase-app-compat\.js/ },
      {
        name: "Firebase Messaging Import",
        pattern: /firebase-messaging-compat\.js/,
      },
      { name: "Firebase Initialize", pattern: /firebase\.initializeApp/ },
      { name: "Messaging Instance", pattern: /firebase\.messaging/ },
      { name: "Background Message Handler", pattern: /onBackgroundMessage/ },
      { name: "Show Notification", pattern: /showNotification/ },
    ];

    console.log(`üîç Validating service worker: ${swPath}`);

    let allValid = true;
    checks.forEach((check) => {
      if (check.pattern.test(content)) {
        console.log(`‚úÖ ${check.name}`);
      } else {
        console.log(`‚ùå ${check.name} - Missing`);
        allValid = false;
      }
    });

    if (allValid) {
      console.log(`\n‚úÖ Service worker validation passed!`);
    } else {
      console.log(`\n‚ùå Service worker validation failed!`);
      process.exit(1);
    }
  } catch (error) {
    console.error(`‚ùå Error validating service worker: ${error.message}`);
    process.exit(1);
  }
}

// Main execution
function main() {
  const args = process.argv.slice(2);
  const command = args[0];

  if (!command || command === "help") {
    showHelp();
    return;
  }

  // Parse options
  let configPath = null;
  let outputPath = null;

  for (let i = 1; i < args.length; i++) {
    if (args[i] === "--config" && i + 1 < args.length) {
      configPath = args[i + 1];
      i++;
    } else if (args[i] === "--output" && i + 1 < args.length) {
      outputPath = args[i + 1];
      i++;
    }
  }

  // Debug logging
  if (process.env.DEBUG) {
    console.log("üîç Debug info:");
    console.log("  Command:", command);
    console.log("  Config path:", configPath);
    console.log("  Output path:", outputPath);
    console.log("  Current directory:", process.cwd());
  }

  switch (command) {
    case "generate": {
      const config = loadFirebaseConfig(configPath);
      const updatedConfig = handleUpdateConfig(config);
      generateServiceWorker(updatedConfig, outputPath);
      break;
    }

    case "validate":
      validateServiceWorker(outputPath);
      break;

    case "update-config":
      updateConfig(configPath);
      break;

    default:
      console.error(`‚ùå Unknown command: ${command}`);
      showHelp();
      process.exit(1);
  }
}

// Run if this file is executed directly
// Cross-platform check for direct execution
const isDirectExecution =
  import.meta.url === `file://${process.argv[1].replace(/\\/g, "/")}` ||
  import.meta.url === `file:///${process.argv[1].replace(/\\/g, "/")}` ||
  process.argv[1].includes("fcm-worker.js");

if (isDirectExecution) {
  main();
}
